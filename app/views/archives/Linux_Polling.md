# Linux 轮询
## read
	它是最原始、性能最低的一种，通过重复重复调用来检查I/O的状态来完成完整数据的读取
## select
	它是在read的基础上的改进的一种方案，通过对文件描述符上的事件状态来进行判断。
    select轮询具有一个较弱的限制，那就是由于它采用一个1024长度的数组来存储状态，所以它最多可以同时检查1024个文件描述符
## poll
	该方案较select有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查。
    但是当文件描述符较多的时候，它的性能还是十分低下的。
## epoll
	该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到I/O事件，将会进行休眠，直到事件发生将它唤醒。
    它是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高。
## kqueue
	该方案的实现方式与epoll类似，不过它仅在FreeBSD系统下存在。

***
**_谪自《深入浅出nodejs》--朴灵_**